<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangxiansen15.github.io</id>
    <title>王先森想要更充实一点</title>
    <updated>2020-09-03T08:14:37.033Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangxiansen15.github.io"/>
    <link rel="self" href="https://wangxiansen15.github.io/atom.xml"/>
    <subtitle>岁月悠悠,，衰微只及肌肤；
热忱抛弃，颓废必至灵魂。</subtitle>
    <logo>https://wangxiansen15.github.io/images/avatar.png</logo>
    <icon>https://wangxiansen15.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 王先森想要更充实一点</rights>
    <entry>
        <title type="html"><![CDATA[浏览器端发起HTTP请求流程]]></title>
        <id>https://wangxiansen15.github.io/post/liu-lan-qi-duan-fa-qi-http-qing-qiu-liu-cheng/</id>
        <link href="https://wangxiansen15.github.io/post/liu-lan-qi-duan-fa-qi-http-qing-qiu-liu-cheng/">
        </link>
        <updated>2020-09-03T08:11:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浏览器端发起http请求流程">浏览器端发起HTTP请求流程</h2>
<h3 id="1构建请求">1.构建请求</h3>
<p>浏览器构建请求行消息，构建完成，浏览器准备发起网络请求</p>
<pre><code class="language-http">GET /index.html HTTP1.1
</code></pre>
<h3 id="2查找缓存">2.查找缓存</h3>
<p>真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否又要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术</strong>。</p>
<p>如果发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并且直接结束请求，而不会再去源服务器重新下载。</p>
<h4 id="查找缓存的好处">查找缓存的好处</h4>
<ul>
<li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li>
<li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li>
</ul>
<p>如果缓存查找失败，就会进入网络请求过程了。</p>
<h3 id="3准备ip地址和端口">3.准备IP地址和端口</h3>
<p>HTTP封装的文本信息是使用<strong>TCP/IP</strong>发送到网络上的，所以在HTTP工作开始之前，浏览器需要通过TCP与服务器建立连接。也就是说<strong>HTTP的内容是通过TCP的传输数据阶段来实现的</strong>。</p>
<p>结合上面的说法，我们知道了，要想进行HTTP网络请求，首先是与服务器建立TCP连接。那么建立TCP连接的第一步就是需要准备<strong>IP地址和端口号</strong>。所以现在我们要利用URL地址来获取IP和端口信息了。</p>
<p>首先我们知道数据包是通过IP地址传输给接收方的。但由于IP地址是数字标识，这就导致难以记忆。所以基于这个需求出现了一个服务。负责把域名和IP地址做一一映射关系。这套域名映射为IP的系统就叫做“<strong>域名系统</strong>”，简称DNS。</p>
<p>结合以上说法，我们应该知道<strong>第一步浏览器会请求DNS返回域名对应的IP</strong>。当然浏览器还提供了DNS数据缓存服务，如果域名已经解析过了，那么浏览器会缓存解析的结果，下次查询时便可以直接使用，这样也会减少一次网络请求。</p>
<p>拿到IP之后，接下来就需要获取端口号了。通常情况下，如果URL没有特别指明端口号，那么HTTP协议默认是80端口。</p>
<h3 id="4等待tcp队列">4.等待TCP队列</h3>
<p>Chrome有一个机制，同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下同时有10个请求发生，那么其中四个请求会进入排队等待状态，直至进行中的请求完成。当然如果当前请求数量少于6，会直接进入下一步，建立TCP连接</p>
<h3 id="5建立tcp连接">5.建立TCP连接</h3>
<h3 id="6发送http请求">6.发送HTTP请求</h3>
<p>在建立了TCP连接之后，浏览器就可以和服务器进行通信了。而HTTP中的数据也是在这个通信过程中传输的。</p>
<p>首先浏览器会向服务器发送请求行，它包括了<strong>请求方法、请求URL和HTTP版本协议</strong></p>
<pre><code class="language-http">GET /index.html HTTP/1.1
</code></pre>
<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是GET。</p>
<p>另一个常用的请求方法是POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过POST方法把用户数据发给服务器。如果使用POST方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p>
<p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的Cookie信息，等等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Boolean() Number() 的转换规则]]></title>
        <id>https://wangxiansen15.github.io/post/boolean-number-de-zhuan-huan-gui-ze/</id>
        <link href="https://wangxiansen15.github.io/post/boolean-number-de-zhuan-huan-gui-ze/">
        </link>
        <updated>2020-04-13T13:41:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="boolean">Boolean()</h2>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">转化为true的值</th>
<th style="text-align:center">转化为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">任何非零的数字，包括Infinity 与-Infinity</td>
<td style="text-align:center">0,-0,NaN</td>
</tr>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">无</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">任何对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">任何非空字符串</td>
<td style="text-align:center">&quot;&quot;(空字符串)</td>
</tr>
</tbody>
</table>
<h2 id="number">Number()</h2>
<ul>
<li>如果是<code>null</code>,转化为<code>0</code></li>
<li>如果是<code>undefined</code> ,转化为NaN</li>
<li>如果是bool值,<code>true</code>转化为<code>1</code>,<code>false</code>转化为<code>0</code></li>
<li>如果是字符串
<ul>
<li>如果字符串中只包含数字(包括前面带正号和负号的情况)，将其转化为十进制数值（前导0会被忽略）</li>
<li>如果字符串中包含有效的浮点格式，会将其转化为对应的浮点数（前导0会被忽略）</li>
<li>如果字符串中包含有效的十六进制格式，会将其转化为同样大小的十进制整数值</li>
<li>如果是空字符串会转化为0</li>
<li>如果上述字符串中包含出上述格式外的所有字符，都会被转化为NaN</li>
</ul>
</li>
<li>如果是对象，首先会调用对象的<code>valueOf()</code>方法，然后对返回的值进行上述规则的转换，如果得到的值为NaN，则会调用对象的toString()方法，然后按照前面的规则转换得到的字符串</li>
</ul>
]]></content>
    </entry>
</feed>