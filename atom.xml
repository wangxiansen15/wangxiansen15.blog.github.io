<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangxiansen15.github.io</id>
    <title>王先森想要更充实一点</title>
    <updated>2020-09-09T12:22:22.310Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangxiansen15.github.io"/>
    <link rel="self" href="https://wangxiansen15.github.io/atom.xml"/>
    <subtitle>岁月悠悠，衰微只及肌肤；
热忱抛弃，颓废必至灵魂。</subtitle>
    <logo>https://wangxiansen15.github.io/images/avatar.png</logo>
    <icon>https://wangxiansen15.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 王先森想要更充实一点</rights>
    <entry>
        <title type="html"><![CDATA[原型模式]]></title>
        <id>https://wangxiansen15.github.io/post/yuan-xing-mo-shi/</id>
        <link href="https://wangxiansen15.github.io/post/yuan-xing-mo-shi/">
        </link>
        <updated>2020-09-09T12:01:39.000Z</updated>
        <content type="html"><![CDATA[<p>我们创建的<strong>每个函数</strong>都有一个<strong>prototype（原型）属性</strong>，这个属性是一个<strong>指针</strong>，指向<strong>一个对象</strong>，而这个对象的用途是<strong>包含可以由特定类型的所有实例共享的属性和方法</strong>。</p>
<pre><code class="language-js">function Person (){

}

Person.prototype.name = &quot;wwj&quot;;
Perosn.prototype.age = &quot;21&quot;;
Person.prototype.sayName = function() {
	alert(this.name);
}
</code></pre>
<h2 id="1理解原型对象">1.理解原型对象</h2>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。<strong>在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性</strong>，这个属性是<strong>指向prototype属性所在函数的指针</strong>。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该<strong>实例内部将包含一个指针（内部属性），指向构造函数的原型对象。</strong></p>
<figure data-type="image" tabindex="1"><img src="https://github.com/wangxiansen15/studyNote/blob/master/img/yuanxinmoshi.png" alt="image" loading="lazy"></figure>
<p>两个方法</p>
<ul>
<li>
<pre><code class="language-js">//确定对象与原型之间的关系
Person.prototype.isPrototypeOf(person1);//true
</code></pre>
</li>
<li>
<pre><code class="language-js">//Object.getPrototypeOf();返回[[Prototype]]的值
Object.getPrototypeOf(person1) == Person.prototype;//true
</code></pre>
</li>
</ul>
<p><strong>搜索模式</strong></p>
<p>每当代码读取某个对象的属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</p>
<p><strong>注意</strong></p>
<p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。使用<code>delete</code>操作符则可以完全删除同名的实例对象，从而让我们能够重新访问原型中的属性。</p>
<p><strong><code>hasOwnProperty()</code></strong></p>
<p>使用<code>hasOwnProperty()</code>方法可以检测一个属性是否存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中时，才会返回true。</p>
<pre><code class="language-js">person1.hasOwnProperty(&quot;name&quot;);//只在给定属性在实例中才返回true
</code></pre>
<h2 id="2原型与in操作符">2.原型与in操作符</h2>
<p><strong>使用in操作符的两种方式</strong></p>
<ul>
<li>单独使用</li>
<li>在for-in循环中使用</li>
</ul>
<h3 id="单独使用in操作符">单独使用in操作符</h3>
<p>在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>
<h3 id="在for-in循环中使用in操作符">在for-in循环中使用in操作符</h3>
<p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的对象也包括存在与原型中的属性。屏蔽了原型中不可枚举属性。</p>
<h3 id="objectkeys"><code>Object.keys()</code></h3>
<p>取得对象上所有可枚举的实例属性，这个方法接收一个对象为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<h3 id="objectgetownpropertynames"><code>Object.getOwnPropertyNames()</code></h3>
<p>得到所有实例对象无论是否可枚举</p>
<pre><code class="language-js">var keys = Object.getOwnPropertyNames(Person.prototype);
</code></pre>
<h2 id="3更简单的原型语法">3.更简单的原型语法</h2>
<pre><code class="language-js">function Person() {

}

Person.prototype = {
	name: 'wwj',
	age: '21',
	sayName: function() {
		alert(this.name);
	}
};
</code></pre>
<h3 id="注意">注意</h3>
<p>以上代码中，我们将<code>Person.prototype</code>设置为等于一个以对象字面量形式创建的新对象。最终效果相同，但有一个例外：constructor属性不再指向Person了。前面曾经介绍过，每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性。而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此construct属性就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管<code>instanceof</code>操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。</p>
<p><strong>避免方法</strong></p>
<pre><code class="language-js">function Person() {

}

Person.prototype = {
	constructor: Person,
	name: 'wwj',
	age: '21',
	sayName: function() {
		alert(this.name);
	}
};
</code></pre>
<p>但是这样设置会导致constructor属性的特性[[Enumerable]]特性会被设置为true。默认情况下，原生的constructor属性是不可枚举的。</p>
<h2 id="4原型的动态性">4.原型的动态性</h2>
<p>对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。因为实例与原型之间的联系只不过是一个指针，而非一个副本，因此在实例中没有找到对应属性就会通过指针去原型对象中去寻找属性。</p>
<p>但是如果重写了整个原型对象，情况会发生变化。因为调用构造函数会为实例添加一个指向最初原型的指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型的联系。</p>
<h2 id="5原生对象的原型">5.原生对象的原型</h2>
<p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原型引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。</p>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。</p>
<h2 id="6原型对象的问题">6.原型对象的问题</h2>
<ul>
<li>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。</li>
<li>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也可以，因为对象实例上的同名属性会隐藏原型中的对应属性。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器端发起HTTP请求流程]]></title>
        <id>https://wangxiansen15.github.io/post/liu-lan-qi-duan-fa-qi-http-qing-qiu-liu-cheng/</id>
        <link href="https://wangxiansen15.github.io/post/liu-lan-qi-duan-fa-qi-http-qing-qiu-liu-cheng/">
        </link>
        <updated>2020-09-03T08:11:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="浏览器端发起http请求流程">浏览器端发起HTTP请求流程</h2>
<h3 id="1构建请求">1.构建请求</h3>
<p>浏览器构建请求行消息，构建完成，浏览器准备发起网络请求</p>
<pre><code class="language-http">GET /index.html HTTP1.1
</code></pre>
<h3 id="2查找缓存">2.查找缓存</h3>
<p>真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否又要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术</strong>。</p>
<p>如果发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并且直接结束请求，而不会再去源服务器重新下载。</p>
<h4 id="查找缓存的好处">查找缓存的好处</h4>
<ul>
<li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li>
<li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li>
</ul>
<p>如果缓存查找失败，就会进入网络请求过程了。</p>
<h3 id="3准备ip地址和端口">3.准备IP地址和端口</h3>
<p>HTTP封装的文本信息是使用<strong>TCP/IP</strong>发送到网络上的，所以在HTTP工作开始之前，浏览器需要通过TCP与服务器建立连接。也就是说<strong>HTTP的内容是通过TCP的传输数据阶段来实现的</strong>。</p>
<p>结合上面的说法，我们知道了，要想进行HTTP网络请求，首先是与服务器建立TCP连接。那么建立TCP连接的第一步就是需要准备<strong>IP地址和端口号</strong>。所以现在我们要利用URL地址来获取IP和端口信息了。</p>
<p>首先我们知道数据包是通过IP地址传输给接收方的。但由于IP地址是数字标识，这就导致难以记忆。所以基于这个需求出现了一个服务。负责把域名和IP地址做一一映射关系。这套域名映射为IP的系统就叫做“<strong>域名系统</strong>”，简称DNS。</p>
<p>结合以上说法，我们应该知道<strong>第一步浏览器会请求DNS返回域名对应的IP</strong>。当然浏览器还提供了DNS数据缓存服务，如果域名已经解析过了，那么浏览器会缓存解析的结果，下次查询时便可以直接使用，这样也会减少一次网络请求。</p>
<p>拿到IP之后，接下来就需要获取端口号了。通常情况下，如果URL没有特别指明端口号，那么HTTP协议默认是80端口。</p>
<h3 id="4等待tcp队列">4.等待TCP队列</h3>
<p>Chrome有一个机制，同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下同时有10个请求发生，那么其中四个请求会进入排队等待状态，直至进行中的请求完成。当然如果当前请求数量少于6，会直接进入下一步，建立TCP连接</p>
<h3 id="5建立tcp连接">5.建立TCP连接</h3>
<h3 id="6发送http请求">6.发送HTTP请求</h3>
<p>在建立了TCP连接之后，浏览器就可以和服务器进行通信了。而HTTP中的数据也是在这个通信过程中传输的。</p>
<p>首先浏览器会向服务器发送请求行，它包括了<strong>请求方法、请求URL和HTTP版本协议</strong></p>
<pre><code class="language-http">GET /index.html HTTP/1.1
</code></pre>
<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是GET。</p>
<p>另一个常用的请求方法是POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过POST方法把用户数据发给服务器。如果使用POST方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p>
<p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的Cookie信息，等等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Boolean() Number() 的转换规则]]></title>
        <id>https://wangxiansen15.github.io/post/boolean-number-de-zhuan-huan-gui-ze/</id>
        <link href="https://wangxiansen15.github.io/post/boolean-number-de-zhuan-huan-gui-ze/">
        </link>
        <updated>2020-04-13T13:41:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="boolean">Boolean()</h2>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">转化为true的值</th>
<th style="text-align:center">转化为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">任何非零的数字，包括Infinity 与-Infinity</td>
<td style="text-align:center">0,-0,NaN</td>
</tr>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">无</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">任何对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">任何非空字符串</td>
<td style="text-align:center">&quot;&quot;(空字符串)</td>
</tr>
</tbody>
</table>
<h2 id="number">Number()</h2>
<ul>
<li>如果是<code>null</code>,转化为<code>0</code></li>
<li>如果是<code>undefined</code> ,转化为NaN</li>
<li>如果是bool值,<code>true</code>转化为<code>1</code>,<code>false</code>转化为<code>0</code></li>
<li>如果是字符串
<ul>
<li>如果字符串中只包含数字(包括前面带正号和负号的情况)，将其转化为十进制数值（前导0会被忽略）</li>
<li>如果字符串中包含有效的浮点格式，会将其转化为对应的浮点数（前导0会被忽略）</li>
<li>如果字符串中包含有效的十六进制格式，会将其转化为同样大小的十进制整数值</li>
<li>如果是空字符串会转化为0</li>
<li>如果上述字符串中包含出上述格式外的所有字符，都会被转化为NaN</li>
</ul>
</li>
<li>如果是对象，首先会调用对象的<code>valueOf()</code>方法，然后对返回的值进行上述规则的转换，如果得到的值为NaN，则会调用对象的toString()方法，然后按照前面的规则转换得到的字符串</li>
</ul>
]]></content>
    </entry>
</feed>