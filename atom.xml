<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangxiansen15.github.io</id>
    <title>王先森想要更充实一点</title>
    <updated>2021-03-01T01:50:42.822Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangxiansen15.github.io"/>
    <link rel="self" href="https://wangxiansen15.github.io/atom.xml"/>
    <subtitle>岁月悠悠，衰微只及肌肤；
热忱抛弃，颓废必至灵魂。</subtitle>
    <logo>https://wangxiansen15.github.io/images/avatar.png</logo>
    <icon>https://wangxiansen15.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 王先森想要更充实一点</rights>
    <entry>
        <title type="html"><![CDATA[水平居中和垂直居中]]></title>
        <id>https://wangxiansen15.github.io/post/shui-ping-ju-zhong-he-chui-zhi-ju-zhong/</id>
        <link href="https://wangxiansen15.github.io/post/shui-ping-ju-zhong-he-chui-zhi-ju-zhong/">
        </link>
        <updated>2021-03-01T00:59:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="水平居中">水平居中</h1>
<h2 id="行内元素">行内元素</h2>
<h3 id="1利用text-align属性">1.利用text-align属性</h3>
<p><strong>如果父元素不是块级元素，先使用display将父元素变为块级元素。</strong></p>
<pre><code class="language-html">&lt;style&gt;
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        text-align: center;
    }
    #son {
    	background: antiquewhite;
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;span id=&quot;son&quot;&gt;我是单行的行内元素&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<h2 id="块级元素">块级元素</h2>
<h3 id="1方案一">1.方案一</h3>
<h3 id="定宽">定宽</h3>
<h4 id="1利用margin0-auto">1.利用margin：0 auto</h4>
<pre><code class="language-html">&lt;style&gt;
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
    }
    #son {
        width: 200px;
        background: antiquewhite;
        margin: 0 auto;
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;span id=&quot;son&quot;&gt;我是有宽度的块级元素&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<h3 id="不定宽">不定宽</h3>
<h4 id="1利用inline-block或者inline转化为行内元素text-align">1.利用inline-block或者inline转化为行内元素，text-align</h4>
<p>这时默认子元素的宽度和父元素一样，这时候需要设置子元素为<code>block:inline-block||inline</code>将其转化为行内块级||行内元素，给父元素设置<code>text-align:center</code></p>
<pre><code class="language-html">&lt;style&gt;    
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        text-align: center;
    }
    #son {
        background-color: green;
        display: inline||inline-block;
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;div id=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="2方案二position">2.方案二position</h3>
<p>首先设置父元素为相对定位，然后设置子元素为绝对定位，设置子元素为<code>left:50%</code>,即让块级元素的左边框水平居中</p>
<ul>
<li>定宽度：<code>margin-left:-width/2</code>；或者设置<code>transform:translateX(-50%);</code></li>
<li>不定宽度：设置<code>transform:translateX(-50%)</code></li>
</ul>
<pre><code class="language-html">&lt;style&gt;
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        position: relative;
    }

    #son {
        width:100px;
        background-color: green;
        position: absolute;
        left: 50%;
        margin-left: -50px;||transform:translateX(-50%);
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;div id=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-html">&lt;style&gt;
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        position: relative;
    }

    .son {
        background-color: green;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;div id=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="3方案三flex">3.方案三flex</h3>
<p>使用<code>display:flex;justify-content:center</code></p>
<pre><code class="language-html"> &lt;style&gt;
     #father {
         width: 500px;
         height: 300px;
         background-color: skyblue;
         display: flex;
         justify-content: center;
     }

    .son {
        background-color: green;
        height: 100px;
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;div id=&quot;son&quot;&gt;我是块元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1 id="垂直居中">垂直居中</h1>
<h2 id="行内元素-2">行内元素</h2>
<p>设置行内元素的高等于盒子的高度</p>
<pre><code class="language-html">&lt;style&gt;
	#father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        line-height: 300px;
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
	wahahahahhahaha
&lt;/div&gt;
</code></pre>
<h2 id="块级元素-2">块级元素</h2>
<h3 id="1方案一使用定位">1.方案一（使用定位）</h3>
<p>首先设置父元素为相对定位，然后设置子元素为绝对定位，设置子元素为<code>top:50%</code>,即让块级元素的上边框垂直居中</p>
<ul>
<li>定宽度：<code>margin-top:-height/2</code>；或者设置<code>transform:translateY(-50%);</code></li>
<li>不定宽度：设置<code>transform:translateY(-50%)</code></li>
</ul>
<pre><code class="language-html">&lt;style&gt;
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        position: relative;
    }
    .son {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background-color: green;
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
	&lt;div class=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;	
&lt;/div&gt;
</code></pre>
<h3 id="2方案二flex">2.方案二（flex）</h3>
<p>利用<code>display:flex;align-items:center</code>进行垂直居中</p>
<pre><code class="language-html">&lt;style&gt;
     #father {
         width: 500px;
         height: 300px;
         background-color: skyblue;
         display: flex;
         align-items: center;
    }
    .son {
        background-color: green;
    }
&lt;style/&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;div class=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h1 id="水平垂直居中">水平垂直居中</h1>
<h2 id="已知高度和宽度">已知高度和宽度</h2>
<h3 id="1使用定位属性">1.使用定位属性</h3>
<h3 id="方案一">方案一</h3>
<p>设置父元素为相对定位，设置子元素为绝对定位，<code>top:0;right:0;bottom:0;left:0;margin:auto;</code></p>
<pre><code class="language-html">&lt;style&gt;
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        position: relative;
    }
    .son {
        width: 100px;
        height: 100px;
        background-color: green;
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        margin: auto;
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
    &lt;div class=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="方案二">方案二</h3>
<p>设置父元素为相对定位，子元素为绝对定位，<code>left:50%;top:50%;margin-left:-width/2;margin-top:-height/2</code></p>
<pre><code class="language-html">&lt;style&gt;
     #father {
         width: 500px;
         height: 300px;
         background-color: skyblue;
         position: relative;
     }
     .son {
         width: 100px;
         height: 100px;
         background-color: green;
         position: absolute;
         top: 50%;
         left: 50%;
         margin-left: -50px;
         margin-top: -50px;
     }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
	&lt;div class=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="2使用flex">2.使用flex</h3>
<p>和下方未知高度和宽度的使用方法一样</p>
<h2 id="未知高度和宽度">未知高度和宽度</h2>
<h3 id="方案一使用定位属性">方案一.使用定位属性</h3>
<p>设置父元素为相对定位，子元素为绝对定位，<code>left:50%;top:50%;transform: translateX(-50%) translateY(-50%);</code></p>
<pre><code class="language-html">&lt;style&gt;
     #father {
         width: 500px;
         height: 300px;
         background-color: skyblue;
         position: relative;
     }
     .son {
         width: 100px;
         height: 100px;
         background-color: green;
         position: absolute;
         top: 50%;
         left: 50%;
         transform:translateX(-50%) translateY(-50%);
     }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
	&lt;div class=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="方案二使用flex">方案二.使用flex</h3>
<pre><code class="language-html">&lt;style&gt;
    #father {
        width: 500px;
        height: 300px;
        background-color: skyblue;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .son {
   		background-color: green;
    }
&lt;/style&gt;
&lt;div id=&quot;father&quot;&gt;
	&lt;div class=&quot;son&quot;&gt;我是块级元素&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>参考博客：https://blog.csdn.net/weixin_37580235/article/details/82317240</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Set]]></title>
        <id>https://wangxiansen15.github.io/post/set/</id>
        <link href="https://wangxiansen15.github.io/post/set/">
        </link>
        <updated>2020-12-02T12:05:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="set">Set</h1>
<p>Set类似于数组，但是成员都是唯一的，没有重复的值。</p>
<p>Set判断元素是否唯一类似于全等运算符(<code>===</code>)，主要的区别是向Set加入值时认为<code>NaN</code>等于自身，而全等运算法认为<code>NaN</code>不等于<code>NaN</code>。</p>
<p>两个对象总是不相等的</p>
<h2 id="set实例的属性和方法">Set实例的属性和方法</h2>
<h3 id="实例属性">实例属性</h3>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是<code>Set</code>函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
<h3 id="实例方法">实例方法</h3>
<h4 id="操作方法">操作方法</h4>
<ul>
<li>Set.prototype.add(value)：添加某个值，返回Set结构本身。</li>
<li>Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>Set.prototype.has(value)：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li>Set.prototype.clear()：清除所有成员，没有返回值。</li>
</ul>
<h4 id="遍历方法">遍历方法</h4>
<ul>
<li>Set.prototype.keys()：返回键名的遍历器</li>
<li>Set.prototype.values()：返回键值的遍历器</li>
<li>Set.prototype.entries()：返回键值对的遍历器</li>
<li>Set.prototype.forEach()：使用回调函数遍历每个成员</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://es6.ruanyifeng.com/#docs/set-map#Set">https://es6.ruanyifeng.com/#docs/set-map#Set</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cookie、LocalStorage、SessionStorage]]></title>
        <id>https://wangxiansen15.github.io/post/cookielocalstoragesessionstorage/</id>
        <link href="https://wangxiansen15.github.io/post/cookielocalstoragesessionstorage/">
        </link>
        <updated>2020-12-01T08:02:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2>
<h3 id="cookie">Cookie</h3>
<p>cookie是小甜饼的意思。顾名思义，cookie确实十分小，大小限制在4KB左右。它的主要用途有保存登录信息。</p>
<h3 id="localstorage">localStorage</h3>
<p>localStorage是HTML5标准中新加入的技术。并不是什么跨时代的新东西。在IE 6时代，就有一个叫userData的东西用于本地存储。</p>
<h3 id="sessionstorage">sessionStorage</h3>
<p>sessionStorage与localStorage的接口类似，但保存数据的生命周期与localStorage不同。它可以将一部分数据在当前会话中保存下来，刷新页面数据依然存在。但当页面关闭后，sessionStorage中的数据就会被清空。</p>
<h2 id="三者的异同">三者的异同</h2>
<figure data-type="image" tabindex="1"><img src="https://wangxiansen15.github.io/post-images/1606809784919.jpg" alt="" loading="lazy"></figure>
<h2 id="应用场景">应用场景</h2>
<p>因为每个HTTP请求都会带着Cookie的信息，所以Cookie要尽可能精简，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往Cookie中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录了。</p>
<p>localStroage大多数存储比较大点的数据。</p>
<h2 id="安全性考虑">安全性考虑</h2>
<p>需要注意，不是什么数据都适合放在Cookie、localStorage和sessionStorage中的。需要时刻注意是否有代码存在XSS注入的风险。所以不要用它们存储系统中的敏感数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[this的指向]]></title>
        <id>https://wangxiansen15.github.io/post/this-de-zhi-xiang/</id>
        <link href="https://wangxiansen15.github.io/post/this-de-zhi-xiang/">
        </link>
        <updated>2020-11-29T08:42:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="默认绑定">默认绑定</h2>
<pre><code class="language-js">function a(){
  console.log(this);
}
a();//window
</code></pre>
<p>这是个普通的函数调用。在这种情况下，this在非严格模式下指向window或global对象。在严格模式下，this指向undefined。</p>
<h2 id="隐式绑定">隐式绑定</h2>
<pre><code class="language-js">var obj = {
  name: 'wwj',
  sayName: function () {
    console.log(this);
  }
};

obj.sayName();//{ name: 'wwj', sayName: [Function: sayName] }
</code></pre>
<p>当我们以一个obj对象来调用这个函数时，<code>sayName()</code>方法内部的this指向obj。</p>
<pre><code class="language-js">let fun = obj.sayName;
fun();//window
</code></pre>
<p>当我们将一个函数引用赋值给某个其他变量并使用这个新的函数去调用该函数时，我们this又是window。</p>
<p>当我们调用fun()时，我们没有指定一个具体的上下文对象。这是一个没有所有者对象的纯函数调用。在这种情况下，sayName()内部的this值退回到<strong>默认绑定</strong>。</p>
<pre><code class="language-js">//setTimeout 的虚拟实现
function setTimeout(callback, delay){
   //等待 'delay' 数个毫秒
   callback();
}
 
setTimeout( obj.display, 1000 );
</code></pre>
<p>在调用setTimeout时，JavaScript在内部将obj.display赋给参数callback。</p>
<p>这种赋值操作会导致display()函数丢失其上下文。当此函数最终在setTimeout函数里面被调用时，display()内部的this值会退回至<strong>默认绑定</strong>.</p>
<h2 id="明确绑定">明确绑定</h2>
<p>为了避免这种情况，我们可以使用<strong>明确绑定方法</strong>，将this的值通过bind()方法绑定到函数上。</p>
<pre><code class="language-js">var obj = {
  name: 'wwj',
  sayName: function () {
    console.log(this);
  }
};
obj.sayName = obj.sayName.bind(obj);
let fun = obj.sayName;
fun();//{ name: 'wwj', sayName: [Function: sayName] }
</code></pre>
<p>即使我们将obj.sayName直接作为callback参数传递给函数，sayName()内部的this也会正确的指向obj。</p>
<h2 id="箭头函数">箭头函数</h2>
<p><strong>由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[var、let、const的区别]]></title>
        <id>https://wangxiansen15.github.io/post/varletconst-de-qu-bie/</id>
        <link href="https://wangxiansen15.github.io/post/varletconst-de-qu-bie/">
        </link>
        <updated>2020-11-28T10:54:31.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>按版本分，var属于ES5，let、const属于ES6</li>
<li>var是函数作用域，let、const是块级作用域</li>
<li>var声明的变量存在变量提升，let和const不存在变量提升</li>
<li>var可以重复声明，但是let和const不可以</li>
<li>let、const会产生暂时性死区。如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错</li>
<li>const声明的变量不得改变值(不过对象的内容可以改变，因为const保存的是对象在堆中的引用地址)</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript中的垃圾回收机制]]></title>
        <id>https://wangxiansen15.github.io/post/javascript-zhong-de-la-ji-hui-shou-ji-zhi/</id>
        <link href="https://wangxiansen15.github.io/post/javascript-zhong-de-la-ji-hui-shou-ji-zhi/">
        </link>
        <updated>2020-11-27T04:41:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="调用栈中的数据是如何回收的">调用栈中的数据是如何回收的？</h2>
<p>当执行一个函数的同时，还有一个<strong>记录当前执行状态的指针(ESP)</strong>，指向调用栈中这个函数的执行上下文，表示当前在执行当前函数。<br>
当函数执行完毕之后，函数的执行流程就进入了它的外层函数，这时候就需要去销毁这个函数的执行上下文了。ESP这时候就能帮我们，JavaScript会将ESP下移到另一个函数的执行上下文，<strong>这个下移操作就是销毁函数上下文的过程</strong>。<br>
因为当ESP向下移动到另一个函数的执行上下文中时，上面函数的执行上下文虽然保存在栈内存中，但是已经是<strong>无效内存</strong>了。比如当函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另一个函数的执行上下文。<br>
总结，当一个函数执行完毕后，<strong>JavaScript会通过下移ESP来销毁该函数保存在栈中的执行上下文</strong>。</p>
<h2 id="堆中的数据是如何回收的">堆中的数据是如何回收的？</h2>
<p><strong>要回收堆中的垃圾数据，就要用到JavaScript中的垃圾回收器了</strong>。<br>
在V8中会把堆分成<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代存放的是生存时间短的对象，老生代存放的是生存时间长的对象</strong>。<br>
对于这两块区域分别使用两个不同的垃圾回收器</p>
<ul>
<li>副垃圾回收器，负责新生代的垃圾回收</li>
<li>主垃圾回收器，负责老生代的垃圾回收</li>
</ul>
<h3 id="垃圾回收器的工作流程">垃圾回收器的工作流程</h3>
<p><strong>无论什么样的垃圾回收器都有着一套共同的执行流程</strong></p>
<ul>
<li>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li>
<li>第二步就是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li>
<li>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，这些不连续空间被称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果要分配较大连续内存的时候，就可能出现内存不足的情况。所以最后一步要整理这些内存碎片，但这一步其实是可选的，因为有的垃圾回收器不会产生内存碎片。</li>
</ul>
<h4 id="副垃圾回收器">副垃圾回收器</h4>
<p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分到新生区，这个区域虽说不大，但是垃圾回收还是比较频繁的。</p>
<p>新生代中用<strong>Scavenge算法</strong>来处理。所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。</p>
<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>
<p>在垃圾回收过程中，首先要对对象区域的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序的排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无线重复使用下去</strong>。</p>
<p>复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小。</strong></p>
<p>正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了<strong>对象晋级策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区。</p>
<h4 id="主垃圾回收器">主垃圾回收器</h4>
<p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一是对象占用空间大，另一个是对象存活时间长。</p>
<p>由于老生区的对象比较大，若要在老生区中使用Scavenge算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，还会浪费一半的空间。因而，主垃圾回收器是采用<strong>标记-清除</strong>的算法进行垃圾回收的。</p>
<h5 id="标记清除算法">标记清除算法</h5>
<p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p>
<p>即当函数执行结束之后，ESP向下移动，指向了另一个函数的执行上下文，这时候如果遍历调用栈，就找不到引用地址的变量，那就意味着这块数据为垃圾数据，被标记为红色。被引用的地址标记为活动对象。</p>
<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程。</p>
<h5 id="标记整理算法">标记整理算法</h5>
<p>这个标记过程依然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="全停顿">全停顿</h4>
<p>V8是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，就需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿</strong>。</p>
<p>因为新生代的空间较小，且存活对象较少，所以全停顿影响不大。</p>
<p>但老生代就不一样，可能占据时间造成卡顿，所以V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记算法</strong>。</p>
<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的JavaScript任务中间执行。这样就可以避免卡顿。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript代码的执行顺序]]></title>
        <id>https://wangxiansen15.github.io/post/javascript-dai-ma-de-zhi-xing-shun-xu/</id>
        <link href="https://wangxiansen15.github.io/post/javascript-dai-ma-de-zhi-xing-shun-xu/">
        </link>
        <updated>2020-10-14T15:03:31.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">showName();
console.log(myname);
var myname = 'wwj'
function showName() {
	console.log(&quot;函数被执行&quot;);
}
</code></pre>
<h2 id="变量提升">变量提升</h2>
<p><strong>所谓的变量提升，是指在JavaScript代码在执行过程中，JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值undefined。</strong></p>
<h2 id="出现变量提升的原因">出现变量提升的原因</h2>
<p><strong>一段JavaScript代码会经过两个阶段；第一个阶段是编译阶段，第二个阶段是执行阶段。</strong></p>
<h3 id="编译阶段">编译阶段</h3>
<pre><code class="language-js">showName();
console.log(myname);
var myname = 'wwj'
function showName() {
	console.log(&quot;函数被执行&quot;);
}
</code></pre>
<ul>
<li>第一行和第二行，这两行不是声明操作，所以JavaScript引擎不会做任何处理</li>
<li>第三行，由于这行是经过var声明的，因此JavaScript引擎将会在环境对象中创建一个名为myname的属性，并使用undefined对其初始化</li>
<li>第四行，JavaScript引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆(HEAP)中，并在环境对象中创建一个showName的属性，然后将该属性值指向堆中函数的位置</li>
</ul>
<h3 id="执行阶段">执行阶段</h3>
<p>JavaScript引擎开始执行代码，按照顺序一行一行地执行。</p>
<ul>
<li>当执行到showName函数时，JavaScript引擎会在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数</li>
<li>接下来打印myname信息，JavaScript引擎继续在变量环境中查找该对象，由于环境变量存在myname变量，并且其值为undefined，所以这时候就输出undefined</li>
<li>接下来执行第三行，把‘wwj’赋给变量，赋值后变量环境中的myname属性值发生改变</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Array]]></title>
        <id>https://wangxiansen15.github.io/post/array/</id>
        <link href="https://wangxiansen15.github.io/post/array/">
        </link>
        <updated>2020-09-17T11:39:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数组的特点">数组的特点</h2>
<ul>
<li>数组的每一项可以保存任何类型的数据</li>
<li>数组的大小可以动态调整</li>
</ul>
<h2 id="创建数组">创建数组</h2>
<ul>
<li>使用new操作符</li>
</ul>
<pre><code class="language-js">  var colors = new Array();//参数只有一个数字，指的是长度；不是只有一个数字，这时候得到的是参数
</code></pre>
<ul>
<li>使用数组字面量表示法</li>
</ul>
<pre><code class="language-js">  var colors = []
</code></pre>
<h2 id="length">length</h2>
<p>当设置的length比数组长时，数组会变长，未定义的数组内容为undefined</p>
<p>当设置的length比数组短时，数组会变短，删除后面的数组内容</p>
<h2 id="检测数组">检测数组</h2>
<ul>
<li>
<p>instanceof</p>
</li>
<li>
<p>instance.constructor === Array</p>
</li>
<li>
<p>Array.isArray(instance)</p>
</li>
<li>
<p>Object.prototype.toString.call(value) == '[object Array]';</p>
</li>
</ul>
<h2 id="方法">方法</h2>
<h3 id="栈方法">栈方法</h3>
<ul>
<li>push()：接收<strong>任意数量</strong>的参数，逐个添加到数组末尾，返回修改后的<strong>数组长度</strong></li>
<li>pop()：不接受参数，从数组末尾<strong>移除最后一项</strong>，减少数组的length值，然后返回<strong>移除的项</strong></li>
</ul>
<pre><code class="language-js">var a = ['a', 2, 'www'];
a.push('c');//4,返回数组长度
console.log(a);//[&quot;a&quot;, 2, &quot;www&quot;, &quot;c&quot;]
a.pop();//c
</code></pre>
<h3 id="队列方法">队列方法</h3>
<p>shift()：移除数组中的第一个项并且返回该项，同时数组长度减一</p>
<p>unshift()：数组前端添加任意个项返回新数组的长度</p>
<pre><code class="language-js">var a = [1,2,3,4,5];
a.shift();//1
a.unshift('a','b','c');//7
a;//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 2, 3, 4, 5]
</code></pre>
<h3 id="重排序方法">重排序方法</h3>
<p>reverse()：反转数组项的顺序</p>
<pre><code class="language-js">a;//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 2, 3, 4, 5]
a.reverse();
a;//[5, 4, 3, 2, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
</code></pre>
<p>sort()：按升序排序数组项，调用每个数组项的toString()方法，然后比较得到的字符串（ascii码）；可以接收一个比较函数为参数，比较函数接受两个参数，如果第一个应该位于第二个之前，返回负数；如果两个参数相等，返回0；如果第一个参数应该位于第二个之后，返回一个正数。</p>
<pre><code class="language-js"> var values = [0, 1, 5, 10, 15];
values.sort();
console.log(values);//[0, 1, 10, 15, 5]

function compare(value1, value2){
    return value1 &gt;= value2 ? 1 : -1;
}
values.sort(compare);
console.log(values);//[0, 1, 5, 10, 15]
</code></pre>
<h3 id="操作方法">操作方法</h3>
<ul>
<li>join(separator)：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认以逗号分割，返回一个字符串</li>
</ul>
<pre><code class="language-js">var values = [0, 1, 5, 10, 15];
var b = values.join();
console.log(b);//0,1,5,10,15
b = values.join('asd');//&quot;0asd1asd5asd10asd15&quot;
</code></pre>
<ul>
<li>concat()：会创建一个副本，然后将接收到的参数添加到副本的末尾，然后返回新创建的数组</li>
</ul>
<pre><code class="language-js">var a = [1,2,3,4];
var b = a.concat(5,6,7,8);
console.log(b,a);// [1, 2, 3, 4, 5, 6, 7, 8] [1, 2, 3, 4]
</code></pre>
<ul>
<li>slice()：接收一或两个参数，要返回项的起始和结束位置。只有一个参数，从开始到结尾；如果有两个参数，返回起始和结束位置之前的项但不包括结束位置的项。不会影响原始数组。如果有一个负数，使用数组长度加上该数；如果结束位置小于起始位置，返回空数组。创建了一个新数组</li>
</ul>
<pre><code class="language-js">var c = b.slice(1);
console.log(b,c);//[1, 2, 3, 4, 5, 6, 7, 8] [2, 3, 4, 5, 6, 7, 8]
c = b.slice(1,3);
console.log(b,c);//[1, 2, 3, 4, 5, 6, 7, 8] [2, 3]
</code></pre>
<ul>
<li>
<p>splice()：</p>
<ul>
<li>删除：可以删除任意数量的项，两个参数：要删除的第一项的位置和要删除的项数</li>
<li>插入：向指定位置插入任意数量的项：三个参数：起始位置、0（要删除的项）、要插入的项（可以传入任意多个项）</li>
<li>替换：可以向指定位置插入任意数量的项，同时删除任意数量的项（结合前两个来看）</li>
</ul>
</li>
</ul>
<h3 id="位置方法">位置方法</h3>
<p>indexOf()和lastIndexOf()：接收两个参数，要查找的项和表示查找起点位置的索引。indexOf从前往后，lastIndexOf从后往前。没找到返回-1.全等匹配。</p>
<pre><code class="language-js">b;//[1, 2, 3, 4, 5, 6, 7, 8]
b.indexOf(2,0);//1
b.lastIndexOf(2,7);//1
</code></pre>
<h3 id="迭代方法">迭代方法</h3>
<p>5个迭代方法。</p>
<p>每个方法接收两个参数：每一项运行的函数和(可选的)运行该函数的作用域对象-影响this的值。传入的函数会接收三个参数，数组项的值，该项在数组中的位置和数组对象本身。但函数返回值不同</p>
<ul>
<li>every()：对数组每一项运行给定函数，该函数每一项都返回true，则返回true</li>
</ul>
<pre><code class="language-js">var number = [1 ,2,3,4,5,6,7];
var res = number.every(function(item, index, array){
    return (item &gt; 2)
});
console.log(res);//false
</code></pre>
<ul>
<li>filiter()：对数组每一项运行给定函数，返回true的项组成的数组</li>
</ul>
<pre><code class="language-js">var a = [1,2,3,4,5,6,7];
var b = a.filter(function(item, index, array) {
    return (item &gt; 3);
});
console.log(b);// [4, 5, 6, 7]
</code></pre>
<ul>
<li>forEach()：对数组每一项运行给定函数，没有返回值，相当于for循环</li>
</ul>
<pre><code class="language-js">var number = [1,2,3,4,5,6,7];
number.forEach(function(item, index, array) {
    array[index] += 1;
});
console.log(number);// [2, 3, 4, 5, 6, 7, 8]
</code></pre>
<ul>
<li>map()：对数组每一项运行给定函数，返回每次函数调用的结果组成的数组</li>
</ul>
<pre><code class="language-js">var number = [1,2,3,4,5,6,7];
var res = number.map(function(item, index, array) {
    return item*2;
});
console.log(res);//[2, 4, 6, 8, 10, 12, 14]
</code></pre>
<ul>
<li>some()：对数组每一项运行给定函数，如果对任意项返回true则返回true</li>
</ul>
<pre><code class="language-js">var number = [1 ,2,3,4,5,6,7];
var res = number.some(function(item, index, array){
    return (item &gt; 2)
});
console.log(res);//true
</code></pre>
<h3 id="归并方法">归并方法</h3>
<p>reduce()和reduceRight()迭代数组的所有项，构建一个最终返回的值。reduce从第一项到最后一项；reducerRight从最后一项到第一项</p>
<p>接收两个参数：每一项调用的函数和（可选）作为归并基础的初始值。函数接收四个参数：前一个值、当前值、项的索引、数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在第二项上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型模式]]></title>
        <id>https://wangxiansen15.github.io/post/yuan-xing-mo-shi/</id>
        <link href="https://wangxiansen15.github.io/post/yuan-xing-mo-shi/">
        </link>
        <updated>2020-09-09T13:21:21.000Z</updated>
        <content type="html"><![CDATA[<p>我们创建的<strong>每个函数</strong>都有一个<strong>prototype（原型）属性</strong>，这个属性是一个<strong>指针</strong>，指向<strong>一个对象</strong>，而这个对象的用途是<strong>包含可以由特定类型的所有实例共享的属性和方法</strong>。</p>
<pre><code class="language-js">function Person (){

}

Person.prototype.name = &quot;wwj&quot;;
Perosn.prototype.age = &quot;21&quot;;
Person.prototype.sayName = function() {
	alert(this.name);
}
</code></pre>
<h2 id="1理解原型对象">1.理解原型对象</h2>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。<strong>在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性</strong>，这个属性是<strong>指向prototype属性所在函数的指针</strong>。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该<strong>实例内部将包含一个指针（内部属性），指向构造函数的原型对象。</strong></p>
<figure data-type="image" tabindex="1"><img src="https://wangxiansen15.github.io/post-images/1599657732805.png" alt="" loading="lazy"></figure>
<p>两个方法</p>
<pre><code class="language-js"> //确定对象与原型之间的关系
 Person.prototype.isPrototypeOf(person1);//true
</code></pre>
<pre><code class="language-js"> //Object.getPrototypeOf();返回[[Prototype]]的值
 Object.getPrototypeOf(person1) == Person.prototype;//true
</code></pre>
<p><strong>搜索模式</strong></p>
<p>每当代码读取某个对象的属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</p>
<p><strong>注意</strong></p>
<p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。使用<code>delete</code>操作符则可以完全删除同名的实例对象，从而让我们能够重新访问原型中的属性。</p>
<p><strong>hasOwnProperty()</strong></p>
<p>使用<code>hasOwnProperty()</code>方法可以检测一个属性是否存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中时，才会返回true。</p>
<pre><code class="language-js">person1.hasOwnProperty(&quot;name&quot;);//只在给定属性在实例中才返回true
</code></pre>
<h2 id="2原型与in操作符">2.原型与in操作符</h2>
<p><strong>使用in操作符的两种方式</strong></p>
<ul>
<li>单独使用</li>
<li>在for-in循环中使用</li>
</ul>
<h3 id="单独使用in操作符">单独使用in操作符</h3>
<p>在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>
<h3 id="在for-in循环中使用in操作符">在for-in循环中使用in操作符</h3>
<p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的对象也包括存在与原型中的属性。屏蔽了原型中不可枚举属性。</p>
<h3 id="objectkeys">Object.keys()</h3>
<p>取得对象上所有可枚举的实例属性，这个方法接收一个对象为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<h3 id="objectgetownpropertynames">Object.getOwnPropertyNames()</h3>
<p>得到所有实例对象无论是否可枚举</p>
<pre><code class="language-js">var keys = Object.getOwnPropertyNames(Person.prototype);
</code></pre>
<h2 id="3更简单的原型语法">3.更简单的原型语法</h2>
<pre><code class="language-js">function Person() {

}

Person.prototype = {
	name: 'wwj',
	age: '21',
	sayName: function() {
		alert(this.name);
	}
};
</code></pre>
<h3 id="注意">注意</h3>
<p>以上代码中，我们将<code>Person.prototype</code>设置为等于一个以对象字面量形式创建的新对象。最终效果相同，但有一个例外：constructor属性不再指向Person了。前面曾经介绍过，每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性。而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此construct属性就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管<code>instanceof</code>操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。</p>
<p><strong>避免方法</strong></p>
<pre><code class="language-js">function Person() {

}

Person.prototype = {
	constructor: Person,
	name: 'wwj',
	age: '21',
	sayName: function() {
		alert(this.name);
	}
};
</code></pre>
<p>但是这样设置会导致constructor属性的特性[[Enumerable]]特性会被设置为true。默认情况下，原生的constructor属性是不可枚举的。</p>
<h2 id="4原型的动态性">4.原型的动态性</h2>
<p>对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。因为实例与原型之间的联系只不过是一个指针，而非一个副本，因此在实例中没有找到对应属性就会通过指针去原型对象中去寻找属性。</p>
<p>但是如果重写了整个原型对象，情况会发生变化。因为调用构造函数会为实例添加一个指向最初原型的指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型的联系。</p>
<h2 id="5原生对象的原型">5.原生对象的原型</h2>
<p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原型引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。</p>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。</p>
<h2 id="6原型对象的问题">6.原型对象的问题</h2>
<ul>
<li>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。</li>
<li>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性也可以，因为对象实例上的同名属性会隐藏原型中的对应属性。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浏览器端发起HTTP请求流程]]></title>
        <id>https://wangxiansen15.github.io/post/liu-lan-qi-duan-fa-qi-http-qing-qiu-liu-cheng/</id>
        <link href="https://wangxiansen15.github.io/post/liu-lan-qi-duan-fa-qi-http-qing-qiu-liu-cheng/">
        </link>
        <updated>2020-09-05T07:18:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1构建请求">1.构建请求</h3>
<p>浏览器构建请求行消息，构建完成，浏览器准备发起网络请求</p>
<pre><code class="language-http">GET /index.html HTTP1.1
</code></pre>
<h3 id="2查找缓存">2.查找缓存</h3>
<p>真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否又要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术</strong>。</p>
<p>如果发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并且直接结束请求，而不会再去源服务器重新下载。</p>
<h4 id="查找缓存的好处">查找缓存的好处</h4>
<ul>
<li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li>
<li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li>
</ul>
<p>如果缓存查找失败，就会进入网络请求过程了。</p>
<h3 id="3准备ip地址和端口">3.准备IP地址和端口</h3>
<p>HTTP封装的文本信息是使用<strong>TCP/IP</strong>发送到网络上的，所以在HTTP工作开始之前，浏览器需要通过TCP与服务器建立连接。也就是说<strong>HTTP的内容是通过TCP的传输数据阶段来实现的</strong>。</p>
<p>结合上面的说法，我们知道了，要想进行HTTP网络请求，首先是与服务器建立TCP连接。那么建立TCP连接的第一步就是需要准备<strong>IP地址和端口号</strong>。所以现在我们要利用URL地址来获取IP和端口信息了。</p>
<p>首先我们知道数据包是通过IP地址传输给接收方的。但由于IP地址是数字标识，这就导致难以记忆。所以基于这个需求出现了一个服务。负责把域名和IP地址做一一映射关系。这套域名映射为IP的系统就叫做“<strong>域名系统</strong>”，简称DNS。</p>
<p>结合以上说法，我们应该知道<strong>第一步浏览器会请求DNS返回域名对应的IP</strong>。当然浏览器还提供了DNS数据缓存服务，如果域名已经解析过了，那么浏览器会缓存解析的结果，下次查询时便可以直接使用，这样也会减少一次网络请求。</p>
<p>拿到IP之后，接下来就需要获取端口号了。通常情况下，如果URL没有特别指明端口号，那么HTTP协议默认是80端口。</p>
<h3 id="4等待tcp队列">4.等待TCP队列</h3>
<p>Chrome有一个机制，同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下同时有10个请求发生，那么其中四个请求会进入排队等待状态，直至进行中的请求完成。当然如果当前请求数量少于6，会直接进入下一步，建立TCP连接</p>
<h3 id="5建立tcp连接">5.建立TCP连接</h3>
<h3 id="6发送http请求">6.发送HTTP请求</h3>
<p>在建立了TCP连接之后，浏览器就可以和服务器进行通信了。而HTTP中的数据也是在这个通信过程中传输的。</p>
<p>首先浏览器会向服务器发送请求行，它包括了<strong>请求方法、请求URL和HTTP版本协议</strong></p>
<pre><code class="language-http">GET /index.html HTTP/1.1
</code></pre>
<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是GET。</p>
<p>另一个常用的请求方法是POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过POST方法把用户数据发给服务器。如果使用POST方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p>
<p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的Cookie信息，等等。</p>
]]></content>
    </entry>
</feed>